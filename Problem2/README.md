# Main Takeaway

OR TermProject——Problem 2

<!--more-->

# Term



## 背景

图书馆的自动化借还机器人



主要解决问题是：

线上提前预约：输入时间和书籍编号进行，支持N+1取书，图书馆内每一层有4个取书机器人，每天根据订单数量完成取书任务，送往每层的中转中枢。

中枢根据预约取书的时间将图书放置在不同的托盘当中，当借阅者来取书的时候，会根据订单信息从不同的托盘中取书（借阅者并不一定在其写的预计取书时间取书）



线下取书：同样的流程，一个在17:00之前，一个在17:00之后



## 问题定义

### 问题1： 书架到中枢

有n个订单，每个订单有m种不同的书籍，每本书的需求量是q

在每天晚上的5点取书，

相当于4辆小车，每个小车最大运载量`kMaxNum=5`，取300本不同的书，规划最小的路径和分配



### 问题2：中枢到取书点，中枢按照取书时间分成多个托盘

当某位同学来取书的时候，按照取书的订单，从不同托盘取书。

取书的流程是：小车将托盘运送至挑拣处，挑拣完成后，

托盘为空则回收，非空则放回货架（空位）。

重复挑拣流程直至订单全部完成，规划最短路径。



假设：小车不碰撞，仅考虑订单的匹配



# 数据输入和初始化

## 输入数据

```
book——id:0~2000,num:1~5
```

```
shelf——id:1~40
```

```
map——(x,y):(0,0)~(20,18)
```

每辆小车的最大运载量(5本书）。



## 初始化

- map init
- selected books init
- books init

读入`lib/*.csv`

确定每个shelf书架上有哪些书需要



## 预处理

- 去掉不需要取书的书架
- 计算每个书架之间的最短距离$d_{ij}$，想取到书架$(x,y)$的书，必须到达$(x,y-1)$的位置





# 任务分配

书籍分配：将500本书分成100组，每组5本书，以满足每辆小车的运载能力。
根据每个货架上的书的数量和位置，尽量将同一货架的书分配给同一辆小车，以减少小车的移动距离。





# 路径规划





# 数学模型

SDVRP（Split Delivery Vehicle Routing Problem）

在 SDVRP 问题中，图书馆有N 个货架，假设图$G = (V; A)$ ，V是结点集合，包含0 和Vc ，其中0 表示放书点，$Vc = \{1, 2,\dots N \}$ 表示书架；图书馆有M 辆相同型号的运输小车，每辆车的最大容量为Q ，第$i$ 个书架的取书量$q_i$可以小于、等于或大于车的容量Q ；每辆配送车的出发点和返回点都必须是放书点，边集合$A = \{(i,j)|i,j \in V_i,i\ne j  \}$表示任意两书架之间的最短路线，距离矩阵$D = (d_{ij} )$表示书架$i $和书架$j$ 之间的距离$d_{ij}$ ，且每个书架可能会被运输小车多次访问；

建立模型如下：

| Symbol    | Definition                                 |
| --------- | ------------------------------------------ |
| $N$       | 有需要取书的书架的数量                     |
| $M$       | 运输小车的数量                             |
| $d_{ij}$  | 书架$i$和书架$j$之间的距离                 |
| $Q$       | 运输小车的装载容量                         |
| $x_{ijk}$ | 运输小车$k$是否通过边($i,j$)的二进制标识符 |
| $y_{ik}$  | 运输小车$k$在书架$i$的配送数量             |
| $q_i$     | 第$i$个书架的需求量                        |
| $s$       | 小车一次取书任务中经过书架的数量           |

$$
\begin{aligned}
&Z=\operatorname*{min}\sum_{i=0}^{N}\sum_{j=0,j\neq i}^{N}\sum_{k=1}^{M}x_{ijk}\cdot d_{ij}\\
s.t.& \\

&0\leq y_{ik}\leq q_{i}, i\in\{0,1,\ldots,N\}, k\in\{1,\ldots,M\}\\

&\sum_{i=0}^{N}\sum_{k=1}^{M}x_{ijk}\geq1, j\in\{0,1,\ldots,N\}\\

&\sum_{i=0}^{N}x_{ipk}-\sum_{j=0}^{N}x_{pjk}=0, p\in\{0,\ldots,N\}, k\in\{1,\ldots,M\} \\

&\sum_{k=1}^{M}y_{ik}=q_{i}, i\in\{0,1,\ldots,N\}\\

&\sum_{i=1}^{N}y_{ik}\leq Q, k\in\{1,\ldots,M\},0<q_{i}<Q, i\in\{0,1,\ldots,N\}\\

&\sum_{i=0}^{N}\sum_{j=0,j\neq i}^{N}x_{ijk}\leq|s|-1, 2\leq|s|\leq n-1\\
\end{aligned}
$$

- 公式(2.1)中定义的目标函数是为了最小化运输小车行驶的总路线长度
- 公式(2.2)表示第$k$辆运输小车给书架的配送量不能超过书架的需求量，且只有在运输小车给顾客进行配送时$y_{ik}$ 才有意义
- 公式(2.3)表示至少有一辆运输小车为书架进行配送服务；
- 公式(2.4)表示到达某点的车辆数应该等于离开该点的车辆数——不会停止不动
- 公式(2.5)表示所有书架的取书任务必须全部被完成；
- 公式(2.6)为运输小车容量约束，即运输小车的容量必须大于等于运输小车在运输途中为顾客配送的总数量；
- 公式(2.7)用于消除支路限制条件









# 优化方案

## 实现思路

1. 先计算最短的能运送货物的路径
2. 再按时间平均分配四个robot



## 蚁群算法

`aco.py`

```
Ant类：用于表示蚂蚁，包含当前的路径、已载的负荷和已访问的客户。
ACO类：实现蚁群算法，用于解决SDVRP问题。
run方法：执行多次迭代以找到最佳路径。
construct_solution方法：为每只蚂蚁构建一条路径。
select_next_customer方法：根据概率选择下一个要访问的客户。
calculate_distance方法：计算路径的总距离。
update_pheromones方法：更新信息素矩阵。
```



蚁群算法（Ant Colony Optimization, ACO）是一种基于自然界蚂蚁觅食行为的优化算法。蚂蚁在寻找食物的过程中，会在路径上留下信息素（pheromone），其他蚂蚁可以感知到这些信息素并趋向于选择信息素浓度较高的路径。这种行为通过反复迭代，逐渐形成了从巢穴到食物源的最优路径。蚁群算法通过模拟这种自然现象，用于求解组合优化问题，例如旅行商问题（TSP）、车辆路径问题（VRP）等。

**alpha**（信息素重要性），**beta**（启发函数的重要性），以及**evaporation rate**（信息素蒸发率）

- 1. 信息素浓度（Pheromone Level）

信息素是蚁群算法中的一个关键概念，模拟自然界中蚂蚁留下信息素来标记路径，引导其他蚂蚁找到食物源的行为。在ACO中：

- **作用**：信息素浓度在算法中用于表示一条路径的优劣，蚂蚁在选择路径时会倾向于选择信息素浓度较高的路径。
- **影响**：路径上信息素的浓度越高，表明该路径被越多的蚂蚁采用并成功找到目标，因此其他蚂蚁也更可能选择这条路径。信息素浓度的更新是通过蒸发和增强机制实现的，有助于算法平衡探索和开发，避免过早收敛于局部最优解。

- 2. 信息素重要性（Alpha, α）

Alpha 是一个参数，用于控制信息素在路径选择过程中的影响力：

- **作用**：决定信息素在蚂蚁决策过程中的相对重要性。Alpha 值越大，蚂蚁在选择路径时越依赖已有的信息素痕迹。
- **影响**：较高的 Alpha 值可能导致蚂蚁快速收敛到一条路径，而忽视其他潜在的、可能更优的路径。较低的 Alpha 值则增加了探索新路径的可能性，但可能降低算法的收敛速度。

- 3. 启发式信息的重要性（Beta, β）

Beta 是另一个参数，它衡量启发式信息（如路径的预期成本或可见性）对蚂蚁决策的影响：

- **作用**：定义了启发式信息（如到目标节点的距离）在蚂蚁选择路径时的重要性。Beta 值越大，蚂蚁在选择下一步路径时更依赖启发式信息。
- **影响**：较高的 Beta 值有助于蚂蚁在短期内找到成本较低的路径，但可能忽略长期的信息素积累，从而可能错过全局最优解。较低的 Beta 值则增强了对信息素的依赖，可能降低了对当前环境的适应性。



以下是蚁群算法的基本思路：

### 1. 初始化
- **参数初始化**：设定蚂蚁数量、信息素初始值、信息素挥发系数、启发因子、期望因子等参数。
- **信息素矩阵初始化**：通常初始化为一个较小的正值，表示初始时路径上的信息素浓度。

### 2. 构造解决方案
每只蚂蚁构造一个可行解，具体步骤如下：
- **选择起点**：通常从起点（如VRP中的仓库）开始。
- **选择下一节点**：基于信息素浓度和启发因子计算概率，选择下一节点。具体公式为：
  \[
  P_{ij} = \frac{[\tau_{ij}]^\alpha \cdot [\eta_{ij}]^\beta}{\sum_{k \in \text{allowed}} [\tau_{ik}]^\alpha \cdot [\eta_{ik}]^\beta}
  \]
  其中：
  - \( \tau_{ij} \) 是路径 \(i\) 到 \(j\) 上的信息素浓度。
  - \( \eta_{ij} \) 是路径 \(i\) 到 \(j\) 的启发值，通常为路径长度的倒数。
  - \( \alpha \) 和 \( \beta \) 分别是信息素因子和启发因子，控制信息素和启发值的相对重要性。

### 3. 更新信息素
在每一轮迭代中，根据每只蚂蚁构造的路径更新信息素矩阵。更新规则为：
- **信息素挥发**：旧的信息素浓度按一定比例衰减。
  \[
  \tau_{ij} \leftarrow (1 - \rho) \cdot \tau_{ij}
  \]
  其中 \( \rho \) 是信息素挥发系数。
- **信息素增加**：每只蚂蚁根据其路径长度在路径上增加信息素。
  \[
  \tau_{ij} \leftarrow \tau_{ij} + \sum_{k=1}^{m} \Delta \tau_{ij}^k
  \]
  其中 \( \Delta \tau_{ij}^k \) 是第 \(k\) 只蚂蚁在路径 \(i\) 到 \(j\) 上增加的信息素，通常与路径长度成反比。

### 4. 迭代
重复步骤2和步骤3，直到达到预定的迭代次数或者解的质量不再显著提升。

### 5. 选择最优解
在所有迭代完成后，选择历史上最优的解作为最终解。

### 应用到SDVRP问题中的蚁群算法

在解决SDVRP（Split Delivery Vehicle Routing Problem）问题中，蚁群算法的应用思路如下：

1. **初始化**：设定蚂蚁数量、车辆数量、车辆容量、各节点需求量、距离矩阵、信息素矩阵等。
2. **构造解决方案**：
   - 每只蚂蚁从起点（仓库）出发，选择下一节点时根据信息素和启发值计算概率。
   - 若车辆容量不足以满足下一个节点的需求，则返回起点卸货，重新出发。
   - 记录每辆车的路径，直到所有需求完成。
3. **更新信息素**：
   - 每轮迭代后，信息素按一定比例挥发。
   - 根据每只蚂蚁的路径长度和路径质量，增加信息素。
4. **迭代优化**：通过多轮迭代，逐步优化路径，直到达到预定迭代次数或者解的质量不再显著提升。
5. **选择最优解**：记录并选择所有迭代中最优的路径作为最终解。

蚁群算法通过模拟自然界蚂蚁觅食的行为，通过不断迭代和信息素更新，可以有效地求解SDVRP问题中的路径优化问题。



## 遗传算法

`ga.py`

```
GeneticAlgorithm类：实现了遗传算法的主要功能，包括初始化种群、适应度计算、选择、交叉和变异。
initialize_population方法：随机生成初始种群。
fitness方法：计算每个个体的适应度（总距离）。
selection方法：根据适应度选择个体进行繁殖。
crossover方法：实现部分映射交叉（PMX）操作。
mutate方法：随机交换个体中的两个客户位置。
run方法：运行遗传算法的主流程。
```





模拟退火算法（Simulated Annealing）：在初始解的基础上，通过随机交换书籍和路径，逐步优化路径。
遗传算法（Genetic Algorithm）：通过编码路径和书籍分配的方式，进行多代选择、交叉和变异，寻找最优路径。
并行优化：
多辆小车的路径规划可以并行进行，确保每辆小车的路径在全局最优的基础上独立优化。
路径细化：
对于每辆小车，可以进一步细化路径规划，如考虑避开障碍物、优化行驶时间等。



## 贪婪算法



将任务分配给四辆小车

将生成的路线按路径长度平均分配给多个小车。这里用**贪心算法**，将最长的路线优先分配给当前负载最小的小车，确保任务负载的均衡。

